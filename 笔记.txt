let -----只有在其代码块内有效
		不能升级
		同一作用域下不能再次申明同一变量
const---不可变
		申明的时候必须赋值
		储存简单的数据类型是不可以改变值
		对象的引用不可以修改，对象里面的数据可以改变
		
结构赋值
	概念：允许按照一定模式，从数组和对象中提取值，并对变量进行赋值，这被称为解构赋值
	
	数组的机构赋值
		let [a, b, c] = [1, 2, 3];
	对象结构赋值
		let { foo, bar } = { foo: "aaa", bar: "bbb" }
		- key 值对应
		解构赋值-别名
		let { foo: f, bar: b } = { foo: "aaa", bar: "bbb" }
		- foo: 原始名称
		- f：别名
		多重解构
		let { foo: [a, b] } = { foo: [10,20], bar: "bbb" }
		
数据结构Set--集合
	集合是由一组无序且唯一（不能重复）的项组成
	特点：key 和 value  相同，没有重复的 value 
	不允许有重复的值
	
	const s = new Set([1,2,3])
	//添加数据   返回数据本身
	s.add('a').add('b')  
	
	//删除数据  返回一个布尔值  表示是否删除成功
	s.delete('a')
			
	//has 判断值是否在数据中  返回一个布尔值
	console.log(s.has("a"))
			
	//clear清楚数据
	s.clear();
	
	keys() 返回键名的遍历器
	values（） 返回键值的遍历器
	entries()返回键值对的遍历器
	forEach(value,key,set )遍历每个成员
	
map数据结构
	let map = new Map([
				['a',"1"],
				["b","2"]
			])
			console.log(map)
			console.log(map.size)
			
			//添加  返回就是数据本身
			map.set('c','3').set('d',"4")
			console.log(map)
			
			//得到键名的值
			console.log(map.get("a"))
			
			//删除值 返回一个布尔值 判断是否删除成功
			console.log(map.delete("b"))
			
			console.log(map.keys())
			
			console.log(map.values())
			
			console.log(map.entries())
			
Iterator 遍历器
	为各种数据结构，提供一个统一的、简便的访问接口
	使得数据结构的成员能够按一种次序排列
	Iterator接口主要提供for ... of消费
	
	凡是有Symbol.iterator属性的数据结构都具有 Iterator 接口
	
	let obj = {
				left:100,
				top:200
			}
			
			//console.log(Object.keys(obj))
			
			obj[Symbol.iterator] = function () {
				let keys = Object.keys(obj);  //["left","top"]
				let len = keys.length;
				let n = 0;
				return {
					next:function(){
						if (n<len) {
							return {
								value:{k:keys[n],v:obj[keys[n++]]},
								done:false
							}
						}else{
							return {
								done:true
							}
						}
					}
				}
			}
			
			for (var {k,v} of obj) {
				console.log(k,v)
			}

class 类
			